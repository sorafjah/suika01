<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>ã‚¹ã‚¤ã‚«ã‚²ãƒ¼ãƒ </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Mochiy+Pop+One&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Mochiy Pop One', sans-serif;
            /* iPhoneã§ã®æ„å›³ã—ãªã„ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚„ã‚ºãƒ¼ãƒ ã‚’é˜²ã */
            touch-action: none;
            overflow: hidden;
            background-color: #f0f0f0; /* ãƒšãƒ¼ã‚¸å…¨ä½“ã®èƒŒæ™¯è‰² */
            overscroll-behavior: none; /* ã‚¹ãƒ¯ã‚¤ãƒ—ã§ã®ã€Œæˆ»ã‚‹ã€ãªã©ã‚’ç„¡åŠ¹åŒ– */
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh; /* ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå…¨ä½“ã®é«˜ã•ã‚’ä½¿ç”¨ */
            min-height: -webkit-fill-available; /* iOS Safariã®ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚’è€ƒæ…® */
            padding: 10px;
            box-sizing: border-box;
        }
        #gameCanvas {
            background-color: #fff; /* ã‚­ãƒ£ãƒ³ãƒã‚¹ã®èƒŒæ™¯è‰² */
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            /* iOSã§ã‚¿ãƒƒãƒ—æ™‚ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’æ¶ˆã™ */
            -webkit-tap-highlight-color: transparent;
        }
        .controls button {
            transition: background-color 0.3s ease, transform 0.1s ease;
        }
        .controls button:active {
            transform: scale(0.95);
        }
        .fruit-emoji {
            display: inline-block;
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
            font-size: 24px;
            vertical-align: middle;
        }
        .popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.85); /* å°‘ã—æ¿ƒã„ã‚ã« */
            color: white;
            padding: 25px; /* å°‘ã—å¤§ãã‚ã« */
            border-radius: 15px;
            text-align: center;
            z-index: 100;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            width: 80%; /* ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®å¹…ã‚’ç”»é¢ã«åˆã‚ã›ã‚‹ */
            max-width: 350px; /* æœ€å¤§å¹… */
        }
        .popup h2 {
            font-size: 1.8em; /* å°‘ã—èª¿æ•´ */
            margin-bottom: 15px;
        }
        .popup p {
            font-size: 1.1em; /* å°‘ã—èª¿æ•´ */
            margin-bottom: 20px;
        }
        .popup button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 12px 25px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 1.1em;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s;
            width: 100%; /* ãƒœã‚¿ãƒ³å¹…ã‚’ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã«åˆã‚ã›ã‚‹ */
            box-sizing: border-box;
        }
        .popup button:hover {
            background-color: #45a049;
        }
        /* iOSã§ã®ãƒœã‚¿ãƒ³ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚¿ã‚¤ãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆ */
        button, input[type="button"], input[type="submit"] {
            -webkit-appearance: none;
            appearance: none;
        }
    </style>
</head>
<body class="bg-amber-100">
    <div class="game-container">
        <h1 class="text-3xl sm:text-4xl font-bold text-orange-600 my-3 sm:my-4">ã‚¹ã‚¤ã‚«ã‚²ãƒ¼ãƒ </h1>

        <div class="bg-white p-1 sm:p-2 rounded-lg shadow-lg mb-1 sm:mb-2 w-full max-w-md">
            <div class="flex justify-between items-center text-base sm:text-xl px-2">
                <div class="mr-2 sm:mr-4">
                    <span class="font-semibold text-slate-700">ã‚¹ã‚³ã‚¢:</span>
                    <span id="score" class="font-bold text-orange-500">0</span>
                </div>
                <div>
                    <span class="font-semibold text-slate-700">æ¬¡:</span>
                    <span id="nextFruitDisplay" class="fruit-emoji"></span>
                </div>
            </div>
        </div>

        <div id="canvasContainer" class="relative border-4 border-orange-400 rounded-lg overflow-hidden shadow-2xl w-full max-w-md">
            <canvas id="gameCanvas"></canvas>
            <div id="gameOverLine" class="absolute h-0.5 bg-red-500 opacity-75 w-full" style="top: 10%;"></div>
            <div id="gameOverPopup" class="popup hidden">
                <h2 class="text-yellow-400">ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼</h2>
                <p>æœ€çµ‚ã‚¹ã‚³ã‚¢: <span id="finalScore">0</span></p>
                <button id="restartButton">ã‚‚ã†ä¸€åº¦éŠã¶</button>
            </div>
        </div>
    </div>

    <script>
        // Matter.js ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
        const { Engine, Render, Runner, Bodies, Composite, Events, Vector } = Matter; // Bodyã‚’é™¤å¤–

        // --- ã‚²ãƒ¼ãƒ è¨­å®š ---
        const FRUITS_DATA = [
            { name: "ã•ãã‚‰ã‚“ã¼", radius: 12, color: "#FFB6C1", emoji: "ğŸ’", score: 1, next: 1 },
            { name: "ã„ã¡ã”", radius: 16, color: "#FF69B4", emoji: "ğŸ“", score: 3, next: 2 },
            { name: "ã¶ã©ã†", radius: 20, color: "#EE82EE", emoji: "ğŸ‡", score: 6, next: 3 },
            { name: "ãƒ‡ã‚³ãƒãƒ³", radius: 25, color: "#FFA500", emoji: "ğŸŠ", score: 10, next: 4 },
            { name: "æŸ¿", radius: 30, color: "#FF8C00", emoji: "ğŸ‘", score: 15, next: 5 }, // Using peach emoji as placeholder for Kaki
            { name: "ã‚Šã‚“ã”", radius: 38, color: "#FF4500", emoji: "ğŸ", score: 21, next: 6 },
            { name: "æ¢¨", radius: 45, color: "#ADFF2F", emoji: "ğŸ", score: 28, next: 7 },
            { name: "ã‚‚ã‚‚", radius: 55, color: "#FFDAB9", emoji: "ğŸ‘", score: 36, next: 8 },
            { name: "ãƒ‘ã‚¤ãƒŠãƒƒãƒ—ãƒ«", radius: 65, color: "#FFFF00", emoji: "ğŸ", score: 45, next: 9 },
            { name: "ãƒ¡ãƒ­ãƒ³", radius: 75, color: "#90EE90", emoji: "ğŸˆ", score: 55, next: 10 },
            { name: "ã‚¹ã‚¤ã‚«", radius: 90, color: "#32CD32", emoji: "ğŸ‰", score: 66, next: null } // Watermelon
        ];

        // HTMLè¦ç´ ã®å–å¾—
        const canvasContainer = document.getElementById('canvasContainer');
        const canvas = document.getElementById('gameCanvas');
        const scoreDisplay = document.getElementById('score');
        const nextFruitDisplay = document.getElementById('nextFruitDisplay');
        const gameOverLineElement = document.getElementById('gameOverLine');
        const gameOverPopup = document.getElementById('gameOverPopup');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');

        // Matter.jsé–¢é€£ã®å¤‰æ•°
        let engine, world, runner;
        // ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ã«é–¢ã™ã‚‹å¤‰æ•°
        let currentFruit = null; // ç¾åœ¨æ“ä½œä¸­ã®ãƒ•ãƒ«ãƒ¼ãƒ„
        let nextFruitType = 0;   // æ¬¡ã«å‡ºç¾ã™ã‚‹ãƒ•ãƒ«ãƒ¼ãƒ„ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
        let score = 0;           // ç¾åœ¨ã®ã‚¹ã‚³ã‚¢
        let canDrop = true;      // ãƒ•ãƒ«ãƒ¼ãƒ„ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã§ãã‚‹ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°
        let gameWidth, gameHeight; // ã‚²ãƒ¼ãƒ ã‚¨ãƒªã‚¢ã®å¹…ã¨é«˜ã•
        let ground, leftWall, rightWall; // å£ã¨åœ°é¢ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        let gameOverLineY;       // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ³ã®Yåº§æ¨™
        let isGameOver = false;  // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼çŠ¶æ…‹ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°

        // --- åˆæœŸåŒ–å‡¦ç† ---
        function setupGame() {
            // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®ãƒªã‚»ãƒƒãƒˆ
            isGameOver = false;
            score = 0;
            updateScoreDisplay();
            gameOverPopup.classList.add('hidden'); // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’éš ã™

            // æ—¢å­˜ã®Matter.jsã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã‚ã‚Œã°ã‚¯ãƒªã‚¢
            if (runner) Runner.stop(runner);
            if (engine) Engine.clear(engine);
            if (world) Composite.clear(world, false); // ãƒ¯ãƒ¼ãƒ«ãƒ‰å†…ã®ç‰©ä½“ã‚‚ã‚¯ãƒªã‚¢

            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã®ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–è¨­å®š
            const containerPadding = 2; // canvasContainerã®borderç­‰ã‚’è€ƒæ…®
            const containerWidth = canvasContainer.clientWidth - containerPadding * 2;
            gameWidth = Math.min(containerWidth, 400); // æœ€å¤§å¹…400px
            gameHeight = gameWidth * 1.5; // åŸºæœ¬ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯” (2:3)

            // ç”»é¢ã®é«˜ã•ã«å¯¾ã™ã‚‹æœ€å¤§æ¯”ç‡ã‚’è€ƒæ…® (ç¸¦é•·ã™ãã‚‹ã®ã‚’é˜²ã)
            const maxViewportHeightRatio = 0.75;
            const availableHeight = window.innerHeight * maxViewportHeightRatio;
            if (gameHeight > availableHeight) {
                gameHeight = availableHeight;
                gameWidth = gameHeight / 1.5;
            }
            gameWidth = Math.min(gameWidth, containerWidth); // æœ€çµ‚çš„ãªå¹…ãŒã‚³ãƒ³ãƒ†ãƒŠå¹…ã‚’è¶…ãˆãªã„ã‚ˆã†ã«å†èª¿æ•´

            canvas.width = gameWidth;
            canvas.height = gameHeight;
            // canvasContainerã®é«˜ã•ã‚‚ã‚­ãƒ£ãƒ³ãƒã‚¹ã«åˆã‚ã›ã‚‹ (ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå´©ã‚Œé˜²æ­¢)
            canvasContainer.style.height = `${gameHeight}px`;
            canvasContainer.style.width = `${gameWidth + containerPadding * 2}px`;

            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ³ã®ä½ç½®è¨­å®š
            gameOverLineY = gameHeight * 0.12; // ä¸Šã‹ã‚‰12%ã®ä½ç½®
            gameOverLineElement.style.top = `${gameOverLineY}px`;

            // Matter.jsã‚¨ãƒ³ã‚¸ãƒ³ã®ä½œæˆ
            engine = Engine.create({
                gravity: { y: 0.6 }, // é‡åŠ›è¨­å®š
                enableSleeping: true  // é™æ­¢ã—ãŸç‰©ä½“ã‚’ã‚¹ãƒªãƒ¼ãƒ—ã•ã›ã¦ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Š
            });
            world = engine.world;

            // å£ã¨åœ°é¢ã®ä½œæˆ (è¡¨ç¤ºã¯ã‚«ã‚¹ã‚¿ãƒ æç”»ã§è¡Œã†ãŸã‚ã€render.visibleã¯false)
            const wallThickness = 30;
            ground = Bodies.rectangle(gameWidth / 2, gameHeight + wallThickness / 2 - 5, gameWidth + wallThickness*2 , wallThickness, { isStatic: true, label: "ground", render: { visible: false } });
            leftWall = Bodies.rectangle(-wallThickness / 2, gameHeight / 2, wallThickness, gameHeight * 2, { isStatic: true, label: "wall", render: { visible: false } });
            rightWall = Bodies.rectangle(gameWidth + wallThickness / 2, gameHeight / 2, wallThickness, gameHeight * 2, { isStatic: true, label: "wall", render: { visible: false } });
            Composite.add(world, [ground, leftWall, rightWall]); // ãƒ¯ãƒ¼ãƒ«ãƒ‰ã«å£ã¨åœ°é¢ã‚’è¿½åŠ 

            // Matter.jsã®Runnerã‚’ä½œæˆãƒ»å®Ÿè¡Œ
            runner = Runner.create();
            Runner.run(runner, engine);

            // æœ€åˆã®ãƒ•ãƒ«ãƒ¼ãƒ„ã®æº–å‚™ã¨ã‚¹ãƒãƒ¼ãƒ³
            prepareNextFruit();
            spawnDroppingFruit();
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
            setupEventListeners();
            // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã®é–‹å§‹
            gameLoop();
        }

        // --- ãƒ•ãƒ«ãƒ¼ãƒ„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆ ---
        function createFruit(x, y, typeIndex, options = {}) {
            const fruitData = FRUITS_DATA[typeIndex];
            if (!fruitData) return null; // ä¸æ­£ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®å ´åˆã¯nullã‚’è¿”ã™
            // Matter.Body ã‚’ç›´æ¥ä½¿ç”¨ã—ã¦å††å½¢ã®ç‰©ä½“ã‚’ä½œæˆ
            return Matter.Bodies.circle(x, y, fruitData.radius, {
                label: "fruit", // ç‰©ä½“ã®ãƒ©ãƒ™ãƒ«
                restitution: 0.3, // åç™ºä¿‚æ•°
                friction: 0.4,    // æ‘©æ“¦ä¿‚æ•°
                density: 0.001 + (fruitData.radius / 5000), // åŠå¾„ã«å¿œã˜ã¦å¯†åº¦ã‚’å°‘ã—å¤‰ãˆã‚‹
                fruitType: typeIndex, // ãƒ•ãƒ«ãƒ¼ãƒ„ã®ç¨®é¡ã‚’ç¤ºã™ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä¿æŒ
                render: { fillStyle: fruitData.color }, // Matter.jsã®ãƒ‡ãƒãƒƒã‚°ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ç”¨ã®è‰²
                ...options // isSleeping: true ãªã©ã€è¿½åŠ ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’é©ç”¨
            });
        }

        // --- æ¬¡ã®ãƒ•ãƒ«ãƒ¼ãƒ„ã‚’æº–å‚™ ---
        function prepareNextFruit() {
            // ã‚¹ã‚³ã‚¢ãŒä½ã„é–“ã¯å°ã•ã„ãƒ•ãƒ«ãƒ¼ãƒ„ãŒå‡ºã‚„ã™ãã™ã‚‹
            const randomPool = score < 50 ? FRUITS_DATA.slice(0, 3) : FRUITS_DATA.slice(0, 5);
            nextFruitType = FRUITS_DATA.indexOf(randomPool[Math.floor(Math.random() * randomPool.length)]);
            updateNextFruitDisplay(); // æ¬¡ã®ãƒ•ãƒ«ãƒ¼ãƒ„è¡¨ç¤ºã‚’æ›´æ–°
        }

        // --- æ¬¡ã®ãƒ•ãƒ«ãƒ¼ãƒ„è¡¨ç¤ºã‚’æ›´æ–° ---
        function updateNextFruitDisplay() {
            const fruitData = FRUITS_DATA[nextFruitType];
            nextFruitDisplay.textContent = fruitData.emoji;
            nextFruitDisplay.style.fontSize = `${Math.max(18, fruitData.radius * 0.7)}px`; // çµµæ–‡å­—ã‚µã‚¤ã‚ºèª¿æ•´
        }

        // --- æ“ä½œä¸­ã®ãƒ•ãƒ«ãƒ¼ãƒ„ã‚’ã‚¹ãƒãƒ¼ãƒ³ ---
        function spawnDroppingFruit() {
            if (isGameOver) return; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã¯ã‚¹ãƒãƒ¼ãƒ³ã—ãªã„
            canDrop = true; // ãƒ‰ãƒ­ãƒƒãƒ—å¯èƒ½ã«ã™ã‚‹
            const fruitData = FRUITS_DATA[nextFruitType];
            // ãƒ‰ãƒ­ãƒƒãƒ—ä½ç½®ã‚’å£éš›ã«ä½™è£•ã‚’æŒãŸã›ã‚‹
            const dropX = Math.max(fruitData.radius + 5, Math.min(gameWidth - fruitData.radius - 5, gameWidth / 2));
            // ãƒ•ãƒ«ãƒ¼ãƒ„ã‚’å°‘ã—ä½ã„ä½ç½®ã‹ã‚‰ã‚¹ãƒãƒ¼ãƒ³ã•ã›ã‚‹ (isSleeping: true ã§æœ€åˆã¯é™æ­¢)
            currentFruit = createFruit(dropX, fruitData.radius * 1.5, nextFruitType, { isSleeping: true });
            if (currentFruit) {
                 Composite.add(world, currentFruit); // ãƒ¯ãƒ¼ãƒ«ãƒ‰ã«ç¾åœ¨ã®ãƒ•ãƒ«ãƒ¼ãƒ„ã‚’è¿½åŠ 
            }
            prepareNextFruit(); // æ¬¡ã®ãƒ•ãƒ«ãƒ¼ãƒ„ã‚’æº–å‚™
        }
        
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®å‚ç…§ã‚’ä¿æŒ (å‰Šé™¤ç”¨)
        let boundHandleMouseMove, boundHandleTouchMove, boundHandleDropClick, boundHandleDropTouch;

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š ---
        function setupEventListeners() {
            // æ—¢å­˜ã®ãƒªã‚¹ãƒŠãƒ¼ã‚’ç¢ºå®Ÿã«å‰Šé™¤ (å†èµ·å‹•æ™‚ã®é‡è¤‡ã‚’é˜²ã)
            if (boundHandleMouseMove) canvasContainer.removeEventListener('mousemove', boundHandleMouseMove);
            if (boundHandleTouchMove) canvasContainer.removeEventListener('touchmove', boundHandleTouchMove);
            if (boundHandleDropClick) canvasContainer.removeEventListener('click', boundHandleDropClick);
            if (boundHandleDropTouch) canvasContainer.removeEventListener('touchend', boundHandleDropTouch);
            restartButton.removeEventListener('click', setupGame);

            // æ–°ã—ã„ãƒªã‚¹ãƒŠãƒ¼é–¢æ•°ã‚’æŸç¸›ã—ã¦ä¿æŒ
            boundHandleMouseMove = handleMouseMove.bind(this);
            boundHandleTouchMove = handleTouchMove.bind(this);
            boundHandleDropClick = handleDrop.bind(this); // clickã¨touchendã§åŒã˜é–¢æ•°ã‚’å‘¼ã¶
            boundHandleDropTouch = handleDrop.bind(this);

            // ãƒã‚¦ã‚¹ãƒ»ã‚¿ãƒƒãƒæ“ä½œã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
            canvasContainer.addEventListener('mousemove', boundHandleMouseMove);
            canvasContainer.addEventListener('touchmove', boundHandleTouchMove, { passive: false }); // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢ã®ãŸã‚passive:false
            canvasContainer.addEventListener('click', boundHandleDropClick);
            canvasContainer.addEventListener('touchend', boundHandleDropTouch);
            
            // Matter.jsã®è¡çªã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ (æ—¢å­˜ã‚’å‰Šé™¤ã—ã¦ã‹ã‚‰å†ç™»éŒ²)
            Events.off(engine, 'collisionStart', handleCollisions);
            Events.on(engine, 'collisionStart', handleCollisions);

            // ãƒªã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            restartButton.addEventListener('click', setupGame);
        }

        // --- ãƒã‚¦ã‚¹ç§»å‹•å‡¦ç† ---
        function handleMouseMove(event) {
            if (!currentFruit || !canDrop || isGameOver) return;
            const rect = canvas.getBoundingClientRect();
            let x = event.clientX - rect.left; // ã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã®Xåº§æ¨™ã‚’å–å¾—
            moveCurrentFruit(x);
        }

        // --- ã‚¿ãƒƒãƒç§»å‹•å‡¦ç† ---
        function handleTouchMove(event) {
            if (!currentFruit || !canDrop || isGameOver || !event.touches.length) return;
            event.preventDefault(); // ç”»é¢ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’é˜²æ­¢
            const rect = canvas.getBoundingClientRect();
            let x = event.touches[0].clientX - rect.left; // ã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã®Xåº§æ¨™ã‚’å–å¾—
            moveCurrentFruit(x);
        }

        // --- æ“ä½œä¸­ãƒ•ãƒ«ãƒ¼ãƒ„ã®ç§»å‹• ---
        function moveCurrentFruit(x) {
            const fruitData = FRUITS_DATA[currentFruit.fruitType];
            // ãƒ•ãƒ«ãƒ¼ãƒ„ãŒå£éš›ã‚®ãƒªã‚®ãƒªã«ãªã‚‰ãªã„ã‚ˆã†ã«Xåº§æ¨™ã‚’åˆ¶é™
            const newX = Math.max(fruitData.radius + 2, Math.min(gameWidth - fruitData.radius - 2, x));
            // Matter.Body ã‚’ç›´æ¥ä½¿ç”¨ã—ã¦ãƒ•ãƒ«ãƒ¼ãƒ„ã®ä½ç½®ã‚’è¨­å®š
            Matter.Body.setPosition(currentFruit, { x: newX, y: currentFruit.position.y });
        }

        // --- ãƒ•ãƒ«ãƒ¼ãƒ„ã®ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç† ---
        function handleDrop() {
            console.log("handleDrop called. currentFruit:", currentFruit, "canDrop:", canDrop, "isGameOver:", isGameOver); // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ­ã‚°
            if (!currentFruit || !canDrop || isGameOver) return; // æ¡ä»¶å¤–ãªã‚‰å‡¦ç†ã—ãªã„
            canDrop = false; // ãƒ‰ãƒ­ãƒƒãƒ—æ“ä½œã‚’ä¸€æ™‚çš„ã«ç„¡åŠ¹åŒ–

            // Matter.Body ã‚’æ˜ç¤ºçš„ã«ä½¿ç”¨ã—ã¦ãƒ•ãƒ«ãƒ¼ãƒ„ã‚’å‹•çš„(dynamic)ã«ã—ã€è¦šé†’(awake)ã•ã›ã‚‹
            Matter.Body.setStatic(currentFruit, false);   // é™çš„ãƒ•ãƒ©ã‚°ã‚’è§£é™¤
            Matter.Body.setSleeping(currentFruit, false); // ã‚¹ãƒªãƒ¼ãƒ—çŠ¶æ…‹ã‚’è§£é™¤ã—ã¦ç‰©ç†æ¼”ç®—ã®å¯¾è±¡ã«ã™ã‚‹
            console.log("Fruit state after setSleeping. isStatic:", currentFruit.isStatic, "isSleeping:", currentFruit.isSleeping, "Body module:", Matter.Body); // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ­ã‚°

            // æ¬¡ã®ãƒ•ãƒ«ãƒ¼ãƒ„ã‚’ã‚¹ãƒãƒ¼ãƒ³ã™ã‚‹ã¾ã§ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
            setTimeout(() => {
                if (!isGameOver) {
                    spawnDroppingFruit();
                }
            }, 600);
        }

        // --- è¡çªå‡¦ç† ---
        function handleCollisions(event) {
            if (isGameOver) return; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã¯å‡¦ç†ã—ãªã„
            const pairs = event.pairs; // è¡çªã—ãŸãƒšã‚¢ã‚’å–å¾—
            pairs.forEach(pair => {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;

                // ä¸¡æ–¹ã¨ã‚‚ãƒ•ãƒ«ãƒ¼ãƒ„ã§ã€åŒã˜ç¨®é¡ã€ã‹ã¤ã‚¹ã‚¤ã‚«ã§ãªã„å ´åˆ
                if (bodyA.label === "fruit" && bodyB.label === "fruit") {
                    if (bodyA.fruitType === bodyB.fruitType && bodyA.fruitType !== null && FRUITS_DATA[bodyA.fruitType].next !== null) {
                        const type = bodyA.fruitType;
                        
                        // çŸ­æ™‚é–“ã§ã®é€£ç¶šåˆä½“ã‚’ä¸€éƒ¨æŠ‘åˆ¶ã™ã‚‹ãŸã‚ã®ãƒ•ãƒ©ã‚° (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)
                        if (bodyA.isMerging || bodyB.isMerging) return;
                        bodyA.isMerging = true;
                        bodyB.isMerging = true;

                        // è¡çªã—ãŸãƒ•ãƒ«ãƒ¼ãƒ„ã‚’ãƒ¯ãƒ¼ãƒ«ãƒ‰ã‹ã‚‰å‰Šé™¤
                        Composite.remove(world, bodyA);
                        Composite.remove(world, bodyB);

                        // æ¬¡ã®æ®µéšã®ãƒ•ãƒ«ãƒ¼ãƒ„ã‚’ç”Ÿæˆ
                        const nextType = FRUITS_DATA[type].next;
                        const newFruitData = FRUITS_DATA[nextType];
                        // åˆä½“ä½ç½®ã¯2ã¤ã®ãƒ•ãƒ«ãƒ¼ãƒ„ã®ä¸­é–“ç‚¹
                        const collisionPoint = Vector.centre(bodyA.position, bodyB.position);
                        
                        let spawnX = collisionPoint.x;
                        let spawnY = collisionPoint.y - newFruitData.radius * 0.05; // ã‚ãšã‹ã«ä¸Šã«èª¿æ•´

                        // æ–°ã—ã„ãƒ•ãƒ«ãƒ¼ãƒ„ãŒå£ã‚„ä»–ã®ãƒ•ãƒ«ãƒ¼ãƒ„ã«ã‚ã‚Šè¾¼ã¾ãªã„ã‚ˆã†ã«ä½ç½®ã‚’å¾®èª¿æ•´
                        spawnX = Math.max(newFruitData.radius, Math.min(gameWidth - newFruitData.radius, spawnX));
                        spawnY = Math.max(newFruitData.radius, spawnY);

                        const newFruit = createFruit(spawnX, spawnY, nextType);
                        if (newFruit) {
                            Composite.add(world, newFruit); // æ–°ã—ã„ãƒ•ãƒ«ãƒ¼ãƒ„ã‚’ãƒ¯ãƒ¼ãƒ«ãƒ‰ã«è¿½åŠ 
                            // Matter.Body ã‚’ç›´æ¥ä½¿ç”¨ã—ã¦åˆä½“ç›´å¾Œã®ãƒ•ãƒ«ãƒ¼ãƒ„ã«ã‚ãšã‹ãªé€Ÿåº¦ã‚’ä¸ãˆã‚‹ (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)
                            Matter.Body.setVelocity(newFruit, { x: (Math.random() - 0.5) * 0.1, y: -0.5 });
                        }

                        score += FRUITS_DATA[type].score * 2; // ã‚¹ã‚³ã‚¢åŠ ç®—
                        updateScoreDisplay(); // ã‚¹ã‚³ã‚¢è¡¨ç¤ºæ›´æ–°
                    }
                }
            });
        }

        // --- ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š ---
        function checkGameOver() {
            if (isGameOver) return;
            const bodies = Composite.allBodies(world); // ãƒ¯ãƒ¼ãƒ«ãƒ‰å†…ã®å…¨ç‰©ä½“ã‚’å–å¾—
            for (let body of bodies) {
                // ãƒ•ãƒ«ãƒ¼ãƒ„ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ï¼ˆã‚¹ãƒªãƒ¼ãƒ—ã—ã¦ãŠã‚‰ãšã€é™çš„ã§ã‚‚ãªã„ï¼‰ãªå ´åˆ
                if (body.label === "fruit" && !body.isSleeping && !body.isStatic) {
                    const fruitRadius = FRUITS_DATA[body.fruitType] ? FRUITS_DATA[body.fruitType].radius : 10;
                    // ãƒ•ãƒ«ãƒ¼ãƒ„ã®ä¸Šç«¯ãŒã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ³ã‚’è¶ŠãˆãŸã‹ãƒã‚§ãƒƒã‚¯
                    if (body.position.y - fruitRadius < gameOverLineY) {
                        if (!body.timeOverLine) { // ãƒ©ã‚¤ãƒ³ã‚’è¶Šãˆå§‹ã‚ãŸæ™‚åˆ»ã‚’è¨˜éŒ²
                            body.timeOverLine = engine.timing.timestamp;
                        } else if (engine.timing.timestamp - body.timeOverLine > 800) { // 0.8ç§’é–“ãƒ©ã‚¤ãƒ³ã‚’è¶Šãˆç¶šã‘ã¦ã„ãŸã‚‰ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
                            triggerGameOver();
                            return;
                        }
                    } else { // ãƒ©ã‚¤ãƒ³ã‚’ä¸‹å›ã£ãŸã‚‰ã‚¿ã‚¤ãƒãƒ¼ãƒªã‚»ãƒƒãƒˆ
                        body.timeOverLine = null;
                    }
                }
            }
        }
        
        // --- ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å‡¦ç† ---
        function triggerGameOver() {
            if (isGameOver) return; // æ—¢ã«ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãªã‚‰ä½•ã‚‚ã—ãªã„
            isGameOver = true;
            if (runner) Runner.stop(runner); // ç‰©ç†ã‚¨ãƒ³ã‚¸ãƒ³ã‚’åœæ­¢
            finalScoreDisplay.textContent = score; // æœ€çµ‚ã‚¹ã‚³ã‚¢ã‚’è¡¨ç¤º
            gameOverPopup.classList.remove('hidden'); // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—è¡¨ç¤º
            // ãƒ‰ãƒ­ãƒƒãƒ—å¾…æ©Ÿä¸­ã®ãƒ•ãƒ«ãƒ¼ãƒ„ãŒã‚ã‚Œã°æ¶ˆå»
            if (currentFruit) {
                Composite.remove(world, currentFruit);
                currentFruit = null;
            }
        }

        // --- ã‚¹ã‚³ã‚¢è¡¨ç¤ºæ›´æ–° ---
        function updateScoreDisplay() {
            scoreDisplay.textContent = score;
        }

        // --- ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ— (æç”»å‡¦ç†) ---
        function gameLoop() {
            if (!isGameOver) {
                // Engine.update(engine); // RunnerãŒå®Ÿè¡Œã—ã¦ã„ã‚‹ã®ã§é€šå¸¸ã¯ä¸è¦
                checkGameOver(); // æ¯ãƒ•ãƒ¬ãƒ¼ãƒ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒã‚§ãƒƒã‚¯
            }

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height); // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢

            // èƒŒæ™¯ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æç”»
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, "#f0e68c"); // Khaki
            gradient.addColorStop(1, "#ffe4b5"); // Moccasin
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ãƒ¯ãƒ¼ãƒ«ãƒ‰å†…ã®å…¨ãƒ•ãƒ«ãƒ¼ãƒ„ã‚’æç”»
            const bodies = Composite.allBodies(world);
            bodies.forEach(body => {
                if (body.label === "fruit" && body.fruitType !== undefined) { // fruitTypeãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æŒã¤ãƒ•ãƒ«ãƒ¼ãƒ„ã®ã¿æç”»
                    const fruitData = FRUITS_DATA[body.fruitType];
                    if (!fruitData) return; // å®‰å…¨ç­–: ä¸æ˜ãªãƒ•ãƒ«ãƒ¼ãƒ„ã‚¿ã‚¤ãƒ—ã¯ã‚¹ã‚­ãƒƒãƒ—

                    ctx.beginPath();
                    ctx.arc(body.position.x, body.position.y, fruitData.radius, 0, Math.PI * 2);
                    
                    // ãƒ•ãƒ«ãƒ¼ãƒ„ã«ç«‹ä½“æ„Ÿã‚’å‡ºã™ãŸã‚ã®æ”¾å°„ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                    const fruitGradient = ctx.createRadialGradient(
                        body.position.x - fruitData.radius * 0.2, 
                        body.position.y - fruitData.radius * 0.2, 
                        fruitData.radius * 0.1,
                        body.position.x, 
                        body.position.y, 
                        fruitData.radius
                    );
                    fruitGradient.addColorStop(0, lightenColor(fruitData.color, 25)); // æ˜ã‚‹ã„ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                    fruitGradient.addColorStop(1, fruitData.color);                   // åŸºæœ¬è‰²
                    
                    ctx.fillStyle = fruitGradient;
                    ctx.fill();
                    ctx.strokeStyle = darkenColor(fruitData.color, 15); // å°‘ã—æš—ã„è‰²ã®æ ç·š
                    ctx.lineWidth = Math.max(1, fruitData.radius * 0.05); // åŠå¾„ã«å¿œã˜ã¦ç·šã®å¤ªã•ã‚’èª¿æ•´
                    ctx.stroke();
                }
            });

            // ãƒ‰ãƒ­ãƒƒãƒ—å¾…æ©Ÿä¸­ã®ãƒ•ãƒ«ãƒ¼ãƒ„ï¼ˆæ“ä½œä¸­ã®ãƒ•ãƒ«ãƒ¼ãƒ„ï¼‰ã‚’æç”» (åŠé€æ˜ã§)
            if (currentFruit && canDrop && !isGameOver && currentFruit.fruitType !== undefined) {
                const fruitData = FRUITS_DATA[currentFruit.fruitType];
                 if (!fruitData) return; // å®‰å…¨ç­–

                ctx.save(); // ç¾åœ¨ã®æç”»çŠ¶æ…‹ã‚’ä¿å­˜
                ctx.globalAlpha = 0.7; // åŠé€æ˜ã§æç”»

                ctx.beginPath();
                ctx.arc(currentFruit.position.x, currentFruit.position.y, fruitData.radius, 0, Math.PI * 2);
                ctx.fillStyle = fruitData.color;
                ctx.fill();
                
                // è½ä¸‹äºˆæ¸¬ç·šã‚’æç”»
                ctx.beginPath();
                ctx.moveTo(currentFruit.position.x, currentFruit.position.y + fruitData.radius);
                ctx.lineTo(currentFruit.position.x, gameHeight - 5); // åœ°é¢ã‚®ãƒªã‚®ãƒªã¾ã§
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.25)';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]); // ç‚¹ç·š
                ctx.stroke();
                ctx.setLineDash([]);     // ç‚¹ç·šè§£é™¤
                ctx.restore(); // æç”»çŠ¶æ…‹ã‚’å…ƒã«æˆ»ã™ (é€æ˜åº¦ãªã©)
            }
            
            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ³ã‚’æç”»
            ctx.beginPath();
            ctx.moveTo(0, gameOverLineY);
            ctx.lineTo(gameWidth, gameOverLineY);
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)'; // èµ¤è‰²ã§åŠé€æ˜
            ctx.lineWidth = 2.5; // å°‘ã—å¤ªã
            ctx.shadowColor = 'rgba(0,0,0,0.3)'; // å½±
            ctx.shadowBlur = 3;
            ctx.stroke();
            ctx.shadowColor = 'transparent'; // å½±ã‚’ãƒªã‚»ãƒƒãƒˆ
            ctx.shadowBlur = 0;

            requestAnimationFrame(gameLoop); // æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¦æ±‚
        }

        // --- ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° ---
        // è‰²ã‚’æ˜ã‚‹ãã™ã‚‹
        function lightenColor(hex, percent) {
            hex = hex.replace(/^#/, '');
            if (hex.length === 3) hex = hex.replace(/(.)/g, '$1$1');
            const num = parseInt(hex, 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, (num >> 16) + amt);
            const G = Math.min(255, (num >> 8 & 0x00FF) + amt);
            const B = Math.min(255, (num & 0x0000FF) + amt);
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        // è‰²ã‚’æš—ãã™ã‚‹
        function darkenColor(hex, percent) {
            hex = hex.replace(/^#/, '');
            if (hex.length === 3) hex = hex.replace(/(.)/g, '$1$1');
            const num = parseInt(hex, 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, (num >> 16) - amt);
            const G = Math.max(0, (num >> 8 & 0x00FF) - amt);
            const B = Math.max(0, (num & 0x0000FF) - amt);
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }
        
        // --- ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºå‡¦ç† ---
        let resizeTimeout;
        function handleResize() {
            // ç”»é¢ã‚µã‚¤ã‚ºãŒå¤‰ã‚ã£ãŸå ´åˆã€ã‚²ãƒ¼ãƒ ã‚’å†åˆæœŸåŒ– (çŠ¶æ…‹ä¿æŒã¯è¤‡é›‘ãªã®ã§ãƒªã‚¹ã‚¿ãƒ¼ãƒˆã§å¯¾å¿œ)
            if (engine) { // ã‚²ãƒ¼ãƒ ãŒæ—¢ã«é–‹å§‹ã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿
                console.log("Resizing, restarting game.");
                // æ—¢å­˜ã® Matter.js ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                if (runner) Runner.stop(runner);
                if (engine) Engine.clear(engine);
                if (world) Composite.clear(world, false);

                if (boundHandleMouseMove) canvasContainer.removeEventListener('mousemove', boundHandleMouseMove);
                if (boundHandleTouchMove) canvasContainer.removeEventListener('touchmove', boundHandleTouchMove);
                if (boundHandleDropClick) canvasContainer.removeEventListener('click', boundHandleDropClick);
                if (boundHandleDropTouch) canvasContainer.removeEventListener('touchend', boundHandleDropTouch);
                // engineãŒã‚¯ãƒªã‚¢ã•ã‚Œã‚‹ã®ã§ã€Events.off(engine, ...) ã¯å‘¼ã°ãªãã¦ã‚‚è‰¯ã„å ´åˆãŒã‚ã‚‹ãŒã€å¿µã®ãŸã‚
                // if (engine) Events.off(engine, 'collisionStart', handleCollisions);
            }
            // ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†: ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆãŒé€£ç¶šã—ã¦ç™ºç”Ÿã™ã‚‹ã®ã‚’é˜²ã
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                console.log("Debounced resize, setting up game.");
                setupGame();
            }, 250);
        }
        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', handleResize); // ç”»é¢å›è»¢æ™‚ã«ã‚‚å¯¾å¿œ

        // --- ã‚²ãƒ¼ãƒ é–‹å§‹ ---
        // DOMContentLoadedã‚’å¾…ã£ã¦ã‹ã‚‰åˆæœŸåŒ–ã™ã‚‹ã“ã¨ã§ã€HTMLè¦ç´ ãŒç¢ºå®Ÿã«èª­ã¿è¾¼ã¾ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
        document.addEventListener('DOMContentLoaded', (event) => {
            setupGame();
        });

    </script>
</body>
</html>
